---
title: "Selection of peptides for retention time tracking - Second iteration"
author: "Ozan Aygun"
date: "May 2017"
output:
  html_document:
    depth: 3
    highlight: tango
    number_sections: yes
    theme: cerulean
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE, fig.align='center',fig.width=5,fig.height=4}
knitr::opts_chunk$set(echo =FALSE, include = TRUE, message = FALSE,warning = FALSE)
```

___

# Introduction and Summary

**The goal of this analysis is to obtain a list of consensus peptides that are consistently detected in our QC runs, with the ultimate purpose of developing quality standards to monitor LC retention time variations.**

**I parsed a list of 80 unique peptides based on the criteria we discussed in our meeting last week. Briefly, these peptides are consistently identified across all the QC runs I described below. They span the entire retention time span, and wherever possible, the entire m/z span we observed across the retention time. As we discussed, I prioritized Histidine containing peptides wherever possible, and 78 out of the 2 final peptides contain at least 1 histidine. I provided the list of peptides along with their features.**  


# Choosing the relevant QC directories for peptide selection

In order to generate the desired peptide list, we selected the following JurkatQC runs:

```{r}
#################################################################
#
# Selection of JurkatQC directories to generate peptide reports
#
#################################################################


setwd("Z:/LabMembers/Ozan/RetentionTimePeptides")
# Get the updated QM list

QM <- readRDS("C:/Users/ozan/Desktop/Ozan_R_utilities/Development/JurkatQCscraper/QMreportArchive.rds")

QM_subset <- QM[which(QM$DistinctPepsCSTotal.number_of. > 28000),]

QM_Franklin <- QM_subset[QM_subset$instrument == "Franklin",][1:3,]
QM_Hubble2 <- QM_subset[QM_subset$instrument == "Hubble2",][1:3,]
QM_Galileo <- QM_subset[QM_subset$instrument == "Galileo",][1:3,]


QM_Beaker <-  QM_subset[(QM_subset$instrument == "Beaker")&(QM_subset$DistinctPepsCSTotal.number_of. >40000),][1,]
QM_Yoda <- QM_subset[(QM_subset$instrument == "Yoda")&(QM_subset$DistinctPepsCSTotal.number_of. >40000),][1,]


QM.summary <- rbind(QM_Galileo,QM_Hubble2,QM_Franklin, QM_Yoda,QM_Beaker)

QM.summary <- dplyr::select(QM.summary, -FileName_instrument_match,
                            -foo,-time,-date)

QM.summary.brief <- dplyr::select(QM.summary, File,MedianMS1peakwidthmid90.matchedspectra.sec.,DistinctPepsCSTotal.number_of.,MedianMS2filltimemid90.matchedspectra.msec. )
knitr::kable(QM.summary, align = "c", format = "pandoc",row.names = F)
```

In addition we included 2 HeLa Thermo Standard Runs that are previously searched at:

- bennett:/msdataSM/Lauren/InstrumentEvaluation/LumosEvaluation_HeLaCurve
- bennett:/msdataSM/Lauren/Hubble2_HeLaCurve

Spectrum Mill protein-peptide report was prepared this file was obtained:

- coston:/JurkatQC/Galileo/2017Q2/20170501/proteinPeptideComparisonColumnsExport.S.1.ssv


```{r, cache=TRUE}

setwd("Z:/LabMembers/Ozan/RetentionTimePeptides")

# Initial loading:
 # pPeptide <- read.csv2("T:/JurkatQC/Galileo/2017Q2/20170501/proteinPeptideComparisonColumnsExport.S.1.ssv",stringsAsFactors = FALSE, na.strings = c(""))

 # Save as RDS for easy loading in future sessions
 saveRDS(pPeptide,file = "pPeptide.rds")
 
setwd("Z:/LabMembers/Ozan/RetentionTimePeptides")
pPeptide <- readRDS("pPeptide.rds")
repeating.names <- names(pPeptide)[1:16]
unique.names <- names(pPeptide)[209:233]

# Better to adjust the header:

first.row <- make.names(pPeptide[1,])
names(pPeptide) <- paste(names(pPeptide),first.row,sep = "__")
pPeptide <- pPeptide[-1,]

# Which sequences are identified in all QC runs?
w <- which(grepl("^Sequence|^sequence__",names(pPeptide)))

peptide.sequences <- pPeptide[,w]
comp.Peptide <- pPeptide[complete.cases(pPeptide[,w]),]
```

In this report, we obtained **`r length(unique(pPeptide$sequence__NA.)) `** unique peptides. **`r length(unique(comp.Peptide$sequence__NA.)) `** of these peptides were identified in all QC runs.

```{r}
# collect the relevant features from the complete peptide set

relevant.features <- c("^bestScore", "^totalIntensity", "^retentionTimeMin","^accession_number", "^best_parent_m_over_z", "^sequence__NA.")

w <- unlist(sapply(relevant.features, function(y){
        which(grepl(y,names(comp.Peptide) ))
}))

relevant.pep <- comp.Peptide[,w]


names(relevant.pep)[grepl("^bestScore",names(relevant.pep))] <- "bestScore"

relevant.pep$bestScore <- as.numeric(relevant.pep$bestScore)

# Define a score cut off

  
```

# Global cut offs

Before going into peptide selection, I applied several filters based on your feedback and suggestions.

## Exclude peptides with missed cleavages

At this stage we filtered any peptide that contains **more than one K or R**, as this will indicate missed cleavages.

```{r}
library(stringr)

number_of_RK <- str_count(toupper(relevant.pep$sequence__NA.), "R|K")

relevant.pep <- relevant.pep[number_of_RK == 1,]

```

This reduced the peptide list to **`r length(relevant.pep$bestScore)`** unique peptides without missed cleavages.

## Exclude peptides with Met, Cys and N-terminal pyro glutamic acid

At this stage we filtered any peptide that contains **M, C or q (N-term)*.

```{r}
n_ter_q <- grepl("^q",relevant.pep$sequence__NA.)
relevant.pep <- relevant.pep[!n_ter_q,]

CorM <- grepl("C|c|m|M",relevant.pep$sequence__NA.)
relevant.pep <- relevant.pep[!CorM,]
```

This reduced the peptide list to **`r length(relevant.pep$bestScore)`** unique peptides without missed cleavages, Met, Cys or N-terminal pyro glutamic acid.

## Abundance (total intensity) cut off

In the first iteration, Karl suggested to incorporate a customized intensity cut off. This will involve eliminating all peptides that are >1/3 the abundance of the median of 50 most abundant (**REMAINING**)peptides.

```{r}

total.intensity <- relevant.pep[,which(grepl("total.intensity",names(relevant.pep)))] 
Top50_most.abundant.peptides.median <- 
```




# Choosing a 'score cut off': relaxing the earlier score cut off

Karl suggested to apply a global score filter. In order to understand what would be a good score cutoff I looked the distribution of the **bestscores** for each peptide across all QC runs:

```{r,fig.align='center', fig.width=4,fig.height=4}
library(ggplot2)

ggplot(aes(x = bestScore),data = relevant.pep)+
 geom_histogram( bins = 100,fill = "blue",color= "red")+
        theme(axis.text.x=element_text(angle = 45),
              panel.background = element_rect(fill = "white"),
              title = element_text(vjust = 0.5),
              plot.title = element_text(hjust = 0.5, face = "bold"))+
        ggtitle("Distribution of best peptide scores")+
        xlab("Best peptide scores")
  
```

Scores have a near Gaussian distribution with a mean of **`r round(mean(relevant.pep$bestScore),2)`**. We choose to include peptides that have the bestScores above this mean score.

```{r}
library(dplyr)
relevant.pep <- dplyr::filter(relevant.pep, bestScore > mean(bestScore))

```

This reduced the peptide list to **`r length(relevant.pep$bestScore)`** unique peptides.

# Distribution of retention time

It would be a good idea to look at the distribution of retention times of the remaining peptides to ensure the distribution is not too skewed:

```{r, fig.align='center', fig.width=9,fig.height=4}

# First simplify the data

total.intensity <- relevant.pep[,which(grepl("totalIntensity",names(relevant.pep)))]
retentionTimeMin <- relevant.pep[,which(grepl("retentionTimeMin",names(relevant.pep)))]

total.intensity <- apply(total.intensity,2,as.numeric)
retentionTimeMin <- apply(retentionTimeMin,2,as.numeric)

relevant.pep$median.total.intensity <- apply(total.intensity,1,median)
relevant.pep$median.retentionTimeMin <-apply(retentionTimeMin,1,median)

hist(relevant.pep$median.retentionTimeMin, breaks = 100, col = "purple",
     main = "Distribution of Median Retention Time (Min)",
     xlab = "Median Retention Time Across all QC runs")
```

As we expected, we generally have more peptides in the higher retention time range.

At this point, I simplified the data by using summary metrics that are robust to outliers. 

Each peptide sequence will be associated with the following features:

- median retention time across all QC runs (Min)
- median total intensity across all QC runs
- best parent m/z

```{r}
# Simplified data
simp.peptide <- dplyr::select(relevant.pep,sequence__NA., bestScore, median.retentionTimeMin,
                              median.total.intensity,best_parent_m_over_z__NA.,
                              accession_number__NA.,accession_numbers__NA.)

w <- which(grepl("__NA.$",names(simp.peptide)))
names(simp.peptide)[w] <- gsub("__NA.$","",names(simp.peptide)[w])
simp.peptide$best_parent_m_over_z <- as.numeric(simp.peptide$best_parent_m_over_z)
```

# Distribution of m/z

This subset of peptides have near-Gaussian m/z distribution:

```{r,fig.align='center', fig.width=4,fig.height=4}

ggplot(aes(x = best_parent_m_over_z),data = simp.peptide)+
 geom_histogram( bins = 100,fill = "red",color= "blue")+
        theme(axis.text.x=element_text(angle = 45),
              panel.background = element_rect(fill = "white"),
              title = element_text(vjust = 0.5),
              plot.title = element_text(hjust = 0.5, face = "bold"))+
        ggtitle("Distribution of best parent m/z")+
        xlab("Best parent m/z")

```

# Partition data into 8 equal retention time bins

I partitioned the data based on 8 retention time bins as we discussed in our meeting:

```{r}
#percentiles = quantile(simp.peptide$median.retentionTimeMin,probs = seq(0,1,0.1))
```



```{r,fig.width=12, fig.align="right", fig.height=4}
simp.peptide$median.retentionTime.Bins <-cut(simp.peptide$median.retentionTimeMin,8)

ggplot(aes(x = best_parent_m_over_z),data = simp.peptide )+
        geom_histogram(fill = "navy", color = "red")+ facet_grid(. ~ median.retentionTime.Bins)+
        theme(axis.text.x=element_text(angle = 45),
              panel.background = element_rect(fill = "white"),
              title = element_text(vjust = 0.5),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              strip.background = element_rect(fill = "slateblue1"))+
        ggtitle("Retention time bins (8 x 11 min bins)")+
         xlab("Best parent m/z")
```

- We notice that the first 2 retention time bins (up to 35 minutes), we have limited representation of m/z, these domain mainly consists of peptides with m/z that are below the average m/z.
- Perhaps this is expected: highly charged peptides elute faster and are not retained in the column beyond 35 minutes.
- The rest of the retention time looks like a good representation of the overall m/z distribution. 

# Evaluating the intensities of the peptides

It is also important to check the intensity selection of the peptides in the retention bins: 

```{r,fig.width=12, fig.align="right", fig.height=4}

ggplot(aes(x = best_parent_m_over_z, y = log10(median.total.intensity)),data = simp.peptide )+
        geom_point(col = "navy",alpha = I(0.2))+ facet_grid(. ~ median.retentionTime.Bins)+
       theme(axis.text.x=element_text(angle = 45,vjust = 0.5),
              panel.background = element_rect(fill = "white"),
              title = element_text(vjust = 0.5),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              strip.background = element_rect(fill = "slateblue1"))+
        ggtitle("Retention time bins (8 x 11 min bins)")+
         xlab("Best parent m/z")
```

## Multivariate regression: Mean intensities are significantly reduced along with the retention time bins

Next, fitting a multivariate regression model to answer the question: **are the mean intensity levels across the retention time bins significantly different from the fist retention time bin, adjusting for the best parent m/z?**

```{r, results="markup"}
lmFit <- lm(log10(median.total.intensity) ~ median.retentionTime.Bins + best_parent_m_over_z, data = simp.peptide)
summary(lmFit)$coeff
```

I concluded that mean intensity is significantly and progressively reduced from the first retention time bin to the last retention time bin (p < 0.05). I am not certain whether this might bring any caveats, but I wanted to point out.

# Assesing the representation of Histidine containing peptides

It appears that we have a good presence of Histidine containing peptides in the remaining subset:

```{r,fig.width=12, fig.align="center", fig.height=4}
# Explore at least one Histidine containing peptides

simp.peptide$histidine <- ifelse(grepl("H",toupper(simp.peptide$sequence)),"At least one H","No H")


ggplot(aes(x = best_parent_m_over_z, y = log(median.total.intensity)),data = simp.peptide )+
        geom_point(aes(color = histidine), alpha = I(0.3))+ facet_grid(. ~ median.retentionTime.Bins)+ scale_color_manual(values = c("red","navy"))+
       theme(axis.text.x=element_text(angle = 45,vjust = 0.5),
              panel.background = element_rect(fill = "white"),
              title = element_text(vjust = 0.5),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              strip.background = element_rect(fill = "slateblue1"))+
        ggtitle("Retention time bins (8 x 11 min bins)")+
         xlab("Best parent m/z")
```


# Algorihtm for the selection of peptides

Peptides will be selected based on the following algorithm:

- Divide the retention time span into 8 percentile bins.
- For a given retention time bin:
    + Prepare 10 equal m/z bins
    + For a given m/z bin:
         + Rank peptides based on total intensity
         + Choose the peptide with highest intensity from the peptides that contain H
         + If the bin doesn't have any H containing peptide, then choose the peptide with highest intensity
    
    
    
```{r}

peptide.selector <- function(simp.peptide){
         temp.selected.peptide <- NULL
         final.selected.peptides <- NULL
         
        for(i in seq_along(levels(simp.peptide$median.retentionTime.Bins))){
                # For a given retention time bin:
                temp <- simp.peptide[simp.peptide$median.retentionTime.Bins == levels(simp.peptide$median.retentionTime.Bins)[i],]
                # Prepare 10 equal m/z bins:
                temp$m_over_z_bins <- cut(temp$best_parent_m_over_z,10)
                for(j in seq_along(levels(temp$m_over_z_bins))){
                        # For a given m/z bin:
                        temp_mz <- temp[temp$m_over_z_bins == levels(temp$m_over_z_bins)[j],] 
                        #Rank peptides based on total intensity
                        temp_mz <- temp_mz[order(temp_mz$median.total.intensity,decreasing = TRUE),]                 
                        if(length(levels(factor(temp_mz$histidine))) == 2){
                                temp.selected.peptide <- temp_mz$sequence[temp_mz$histidine == "At least one H"][1]
                        }else{
                                temp.selected.peptide <- temp_mz$sequence[1]
                        }
                                
                    final.selected.peptides <- c(final.selected.peptides, temp.selected.peptide) 
                }
                
        }
         # Return a data frame with all features of the selected 80 peptides:
         
         selected.peptides <- simp.peptide[simp.peptide$sequence %in% final.selected.peptides,]
         return(selected.peptides)
}

selected.peptides <- peptide.selector(simp.peptide = simp.peptide)

```

# Exploring the final selection of peptides


```{r,fig.width=12, fig.align="center", fig.height=4}
# Explore at least one Histidine containing peptides

ggplot(aes(x = best_parent_m_over_z, y = log10(median.total.intensity)),data = selected.peptides )+
        geom_line(color = "navy")+
        geom_point(aes(color = histidine), size = 2)+ facet_grid(. ~ median.retentionTime.Bins)+ scale_color_manual(values = c("red","navy"))+
        theme(axis.text.x=element_text(angle = 45,vjust = 0.5),
              panel.background = element_rect(fill = "white"),
              title = element_text(vjust = 0.5),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              strip.background = element_rect(fill = "slateblue1"))+ 
        ggtitle("Retention time bins (8 x 11 min bins)")+
        xlab("Best parent m/z")
```

**Note that I just connected the peptide data points to make any trends in intensity fluctations more obvious.**

These **`r length(unique(selected.peptides$sequence))`** distinct peptides come from **`r length(unique(selected.peptides$accession_number))`** unique proteins (uniprot accession number).

# Final list of the 80 selected peptides and their features

Therefore, we have selected a fair amount of peptides that are both representative (i.e: detected in all of the QC runs we profiled) as well as spanning retention time and m/z spans fairly well. I welcome your feedback on refining the selection of peptides as necessary.

The current selection of the peptides are:

```{r}
knitr::kable(selected.peptides, align = "c", format = "pandoc",row.names = F)
setwd("Z:/LabMembers/Ozan/RetentionTimePeptides")
write.csv(selected.peptides,file = "Selected.peptides.csv", row.names = FALSE)

```

  